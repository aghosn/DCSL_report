\chapter{Design}

\section{Re-Designing Memory Management}
%TODO aghosn: ADD FIGURES!

Light-weight contexts live at the boundary between user applications and the kernel memory management.
As such, they require flexible and efficient high-level memory abstractions.
More precisely, the LwC library needs to copy, add, share, and remove memory mappings between different contexts.
To facilitate these manipulations, an address space needs to be represented as a set of contiguous memory regions with the same access rights, i.e., contiguous portions of the address space that can be treated in the same fashion.

Dune's original design only provides a rigid API for page table manipulations.
Page tables are a low-level memory representation where page-sized entries are accessed via four levels of indirection.
Transformations are performed on a per-page basis.
In the context of Dune, this representation is an over-simplification of memory management that provides the basic functionalities needed by Dune's applications.
In Dune, guest memory is mapped, via the EPT, as closely as possible to the host address space.
This rigid mapping simplifies VMExits by removing the need for syscall argument interposition and address translation.
While acceptable from Dune's point of view, this design is not flexible enough to efficiently implement LwCs.
Moreover, the page-table abstraction is agnostic to memory regions and too low-level for users to easily reflect upon copied and shared memory between contexts.
We thus identified the need for higher-level memory abstractions and designed a new Dune's \textit{mmu}.

Our memory design is a simplified version of the Linux kernel mmu.
We maintain the same layers, i.e., memory regions, virtual memory regions, and page tables.
A memory region (\textit{mm}) represents an address space.
It can be seen as a collection of virtual memory regions (\textit{vmas}).
A vma abstracts a contiguous virtual memory region with uniform access rights.
An mm is associated with a page root, i.e., a hierarchy of page tables, that reflects the vmas it contains.
We enforce modularity by exposing, at each layer, an API with the expected functionalities.
Any layer's implementation can therefore be modified independently.
Any level-specific functionality is completely encapsulated at the relevant layer.
For example, mms and vmas are oblivious to copy-on-write mechanisms implemented at the page table level.
Considering LwCs, mms provide the proper high-level abstraction to perform memory layout operations.
The LwC library can easily copy and modify memory mappings.
All modifications are automatically applied to lower-levels thanks to cascading calls to underlying abstractions interfaces.

The memory hierarchy's built-in modularity allows to tune any memory management level to suit our need.
As long as interfaces are maintained, the implementation's details can be modified as needed.
This extra flexibility, compared to Dune's default mmu implementation, unfolds two major advantages: 1) memory management operations and data-structures can be optimized on a per-application performance basis, and 2) backward compatibility with existing Dune's applications is maintained.
The second point is crucial to evaluate our implementation in Chapter[REF].
With regard to LwC, the first point enables to experiment different mms and vmas implementations.
While only superficially explored in this paper, we plan to perform more extensive experiments to improve LwC performances in the future.

\section{LwC as a Dune Library}
Light-Weight Contexts are implemented as a Dune user library.
We adapted the original LwC design to Dune.
Implementing LwCs in Dune presents major benefits.
First, interfaces are narrower and simpler, especially compared to a standard kernel.
Mmu data-structures are simpler and less expensive to initialize and maintain. 
Second, as explained in Section[REF], memory management's implementation and interfaces can be tuned for LwC operations.
Moreover, underlying data structures can be tailored to simplify LwC common operations and decrease their initialization and execution costs.
%TODO aghosn: develop

%LwC == memory stuff + file descriptors (todo)
%API
%very close to what we get in the original implementation.
%Simpler implementation see section 4.
%root LwC.



